"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
class Char {
    constructor(writer, l, gl, initialGhosts = '', specialType) {
        this.ghostsBefore = [];
        this.ghostsAfter = [];
        this.stop = false;
        this.afterGlitchChance = 0;
        this.writer = writer;
        this.setProps(l, gl, initialGhosts, specialType);
        if (writer.options.letterize) {
            this.els = {
                ghostsBeforeEl: document.createElement('span'),
                letterEl: document.createElement('span'),
                ghostsAfterEl: document.createElement('span'),
            };
            this.els.ghostsBeforeEl.className = 'gw-ghosts';
            this.els.ghostsAfterEl.className = 'gw-ghosts';
            this.els.letterEl.className = 'gw-letter';
        }
    }
    setProps(l, gl, initialGhosts = '', specialType) {
        const { options } = this.writer;
        this.l = l;
        this.gl = gl;
        this.specialType = specialType;
        this.ghostsBefore = [...initialGhosts];
        this.writer.state.nGhosts += initialGhosts.length;
        this.stepsLeft = options.stepsLeft;
        if (specialType === 'tag')
            this.stepsLeft = 0;
        else if (utils_1.isSpecialChar(gl))
            this.specialType = 'whitespace';
        this.afterGlitchChance =
            (options.ghostChance + options.changeChance) / 3.7;
    }
    reset(l, gl, initialGhosts = '', specialType) {
        this.setProps(l, gl, initialGhosts, specialType);
        if (this.els)
            this.els.letterEl.className = 'gw-letter';
    }
    get string() {
        const { l: char, ghostsAfter, ghostsBefore } = this;
        return ghostsBefore.join('') + char + ghostsAfter.join('');
    }
    get finished() {
        const { l: char, gl: goal, ghostsBefore, ghostsAfter } = this;
        return ((char === goal &&
            ghostsBefore.length === 0 &&
            ghostsAfter.length === 0) ||
            this.specialType === 'tag');
    }
    get interval() {
        let interval = this.writer.options.genInterval;
        if (this.specialType === 'whitespace')
            interval /= 1.8;
        return interval;
    }
    writeToElement() {
        if (!this.els)
            return;
        const { ghostsBeforeEl, ghostsAfterEl, letterEl } = this.els;
        letterEl.innerHTML = this.l;
        ghostsBeforeEl.textContent = this.ghostsBefore.join('');
        ghostsAfterEl.textContent = this.ghostsAfter.join('');
    }
    set spanElement(el) {
        if (!this.els)
            return;
        this.els.charEl = el;
        this.appendChildren();
    }
    appendChildren() {
        var _a, _b;
        (_b = (_a = this.els) === null || _a === void 0 ? void 0 : _a.charEl) === null || _b === void 0 ? void 0 : _b.append(this.els.ghostsBeforeEl, this.els.letterEl, this.els.ghostsAfterEl);
        this.writeToElement();
    }
    type() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const { writer } = this;
            if (this.specialType === 'tag') {
                this.l = this.gl;
                writer.emiter.call('step');
                writer.state.progress.increase();
                return true;
            }
            const loop = () => __awaiter(this, void 0, void 0, function* () {
                yield utils_1.wait(this.interval);
                const lastString = this.string;
                this.step();
                if (lastString !== this.string) {
                    writer.emiter.call('step');
                    this.writeToElement();
                }
                !writer.options.endless && this.stepsLeft--;
            });
            yield utils_1.wait(writer.options.genInitDelay);
            yield utils_1.promiseWhile(() => (!this.finished || writer.options.endless) &&
                !writer.state.isPaused &&
                !this.stop, loop);
            if (this.finished) {
                writer.state.progress.increase();
                (_b = (_a = this.els) === null || _a === void 0 ? void 0 : _a.charEl) === null || _b === void 0 ? void 0 : _b.classList.add('gw-finished');
                (_c = this.els) === null || _c === void 0 ? void 0 : _c.letterEl.classList.remove('gw-glitched');
            }
            return this.finished;
        });
    }
    step() {
        var _a, _b;
        const { writer } = this;
        if ((this.stepsLeft > 0 && this.l !== this.gl) ||
            (utils_1.coinFlip(this.afterGlitchChance) &&
                this.specialType !== 'whitespace') ||
            writer.options.endless) {
            /**
             * IS GROWING
             */
            const { ghostChance, changeChance } = writer.options;
            if (utils_1.coinFlip(ghostChance)) {
                if (writer.state.ghostsInLimit)
                    this.addGhost();
                else
                    this.removeGhost();
            }
            if (utils_1.coinFlip(changeChance)) {
                (_a = this.els) === null || _a === void 0 ? void 0 : _a.letterEl.classList.add('gw-glitched');
                this.l = writer.options.ghost;
            }
        }
        else if (!this.finished) {
            /**
             * IS SHRINKING
             */
            (_b = this.els) === null || _b === void 0 ? void 0 : _b.letterEl.classList.remove('gw-glitched');
            this.l = this.gl;
            this.removeGhost();
        }
    }
    addGhost() {
        const l = this.writer.options.ghost;
        this.writer.state.nGhosts++;
        utils_1.coinFlip()
            ? insertGhost(this.ghostsBefore, l)
            : insertGhost(this.ghostsAfter, l);
    }
    removeGhost() {
        const deleted = utils_1.coinFlip() && this.ghostsBefore.length > 0
            ? utils_1.deleteRandom(this.ghostsBefore)
            : utils_1.deleteRandom(this.ghostsAfter);
        if (deleted)
            this.writer.state.nGhosts--;
    }
}
exports.default = Char;
function insertGhost(ghostsArray, ghost) {
    const { length } = ghostsArray;
    ghostsArray.splice(utils_1.random(0, length, 'floor'), 0, ghost);
}
