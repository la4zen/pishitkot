'use strict';var Vue=require('vue');function _interopDefaultLegacy(e){return e&&typeof e==='object'&&'default'in e?e:{'default':e}}var Vue__default=/*#__PURE__*/_interopDefaultLegacy(Vue);function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}/* eslint-disable no-unused-vars */
function random(min, max, math) {
    const result = Math.random() * (max - min) + min;
    if (math) {
        // eslint-disable-next-line default-case
        switch (math) {
            case 'floor':
                return Math.floor(result);
            case 'round':
                return Math.round(result);
            case 'ceil':
                return Math.ceil(result);
        }
    }
    return result;
}
const deleteRandom = (array) => array.splice(random(0, array.length, 'floor'), 1).length > 0;
function getRandom(iterable) {
    return iterable[random(0, iterable.length, 'floor')];
}
function filterDuplicates(iterable) {
    const isString = typeof iterable === 'string', result = [];
    new Set(iterable).forEach(x => result.push(x));
    return isString ? result.join('') : result;
}
function parseCharset(input) {
    let result;
    // Charset is a string
    if (typeof input === 'string')
        result = input;
    // Charset is an array
    else if (input.length)
        result = input.join('');
    // Charset is a Set
    else
        result = Array.from(input).join('');
    return result;
}
const wait = (time) => new Promise(resolve => setTimeout(() => resolve(time), time));
function promiseWhile(conditionFunc, actionPromise) {
    const whilst = () => conditionFunc() ? actionPromise().then(whilst) : Promise.resolve();
    return whilst();
}
const arrayOfTheSame = (value, length) => new Array(length).fill(value);
const animateWithClass = (element, className) => {
    element.classList.remove(className);
    // eslint-disable-next-line no-void
    void element.offsetWidth;
    element.classList.add(className);
};
function getRandomFromRange(range, round = true) {
    return typeof range === 'number'
        ? range
        : random(...range, round ? 'round' : undefined);
}
const coinFlip = (p = 0.5) => Math.random() < p;
const letterToLetterItem = (string) => ({
    value: string,
});
const stringToLetterItems = (string) => [...string].map(letterToLetterItem);
const isSpecialChar = (l) => ['\t', '\n', '\r', '\f', '\v', '', ' '].includes(l);
const findHTMLPattern = '(&(?:[a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});)|(<style.+?>.+?</style>|<script.+?>.+?</script>|<(?:!|/?[a-zA-Z]+).*?/?>)';
function htmlToArray(string) {
    const reg = new RegExp(findHTMLPattern, 'gi'), resultArray = [];
    let find, lastIndex = 0;
    // eslint-disable-next-line no-cond-assign
    while ((find = reg.exec(string))) {
        const from = find.index, to = reg.lastIndex, stringBefore = string.slice(lastIndex, from);
        lastIndex = to;
        stringBefore && resultArray.push(...stringToLetterItems(stringBefore));
        const result = {
            value: find[0],
            type: find[1] !== undefined ? 'html_entity' : 'tag',
        };
        resultArray.push(result);
    }
    string.length > lastIndex &&
        resultArray.push(...stringToLetterItems(string.slice(lastIndex)));
    // return resultArray.map(l =>
    // 	l.type
    // 		? l
    // 		: {
    // 				value: l.value,
    // 				type: isSpecialChar(l.value) ? 'whitespace' : undefined,
    // 		  },
    // )
    return resultArray;
}
function filterHtml(string) {
    const reg = new RegExp(findHTMLPattern, 'g');
    return string.replace(reg, '');
}const glyphs = {
    nier: '一二三四五六七八九十百千上下左右中大小月日年早木林山川土空田天生花草虫犬人名女男子目耳口手足見音力気円入出立休先夕本文字学校村町森正水火玉王石竹糸貝車金雨赤青白数多少万半形太細広長点丸交光角計直線矢弱強高同親母父姉兄弟妹自友体毛頭顔首心時曜朝昼夜分週春夏秋冬今新古間方北南東西遠近前後内外場地国園谷野原里市京風雪雲池海岩星室戸家寺通門道話言答声聞語読書記紙画絵図工教晴思考知才理算作元食肉馬牛魚鳥羽鳴麦米茶色黄黒来行帰歩走止活店買売午汽弓回会組船明社切電毎合当台楽公引科歌刀番用何',
    full: 'ABCDĐEFGHIJKLMNOPQRSTUVWXYZabcdđefghijklmnopqrstuvwxyzĄąĆćŻżŹźŃńóŁłАБВГҐДЂЕЁЄЖЗЅИІЇЙЈКЛЉМНЊОПРСТЋУЎФХЦЧЏШЩЪЫЬЭЮЯабвгґдђеёєжзѕиіїйјклљмнњопрстћуўфхцчџшщъыьэюяΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρστυφχψωάΆέΈέΉίϊΐΊόΌύΰϋΎΫΏĂÂÊÔƠƯăâêôơư一二三四五六七八九十百千上下左右中大小月日年早木林山川土空田天生花草虫犬人名女男子目耳口手足見音力気円入出立休先夕本文字学校村町森正水火玉王石竹糸貝車金雨赤青白数多少万半形太細広長点丸交光角計直線矢弱強高同親母父姉兄弟妹自友体毛頭顔首心時曜朝昼夜分週春夏秋冬今新古間方北南東西遠近前後内外場地国園谷野原里市京風雪雲池海岩星室戸家寺通門道話言答声聞語読書記紙画絵図工教晴思考知才理算作元食肉馬牛魚鳥羽鳴麦米茶色黄黒来行帰歩走止活店買売午汽弓回会組船明社切電毎合当台楽公引科歌刀番用何ĂÂÊÔƠƯăâêôơư1234567890‘?’“!”(%)[#]{@}/\\&<-+÷×=>$€£¥¢:;,.*•°·…±†‡æ«»¦¯—–~˜¨_øÞ¿▬▭▮▯┐└╛░▒▓○‼⁇⁈⁉‽ℴℵℶℷℸℲ℮ℯ⅁⅂⅃⅄₠₡₢₣₤₥₦₧₨₩₪₫€₭₮₯₰₱₲₳₴₵₶₷₸₹₺₻₼₽₾₿          ',
    letterlike: 'ABCDĐEFGHIJKLMNOPQRSTUVWXYZabcdđefghijklmnopqrstuvwxyzĄąĆćŻżŹźŃńóŁłАБВГҐДЂЕЁЄЖЗЅИІЇЙЈКЛЉМНЊОПРСТЋУЎФХЦЧЏШЩЪЫЬЭЮЯабвгґдђеёєжзѕиіїйјклљмнњопрстћуўфхцчџшщъыьэюяΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρστυφχψωάΆέΈέΉίϊΐΊόΌύΰϋΎΫΏĂÂÊÔƠƯăâêôơưĂÂÊÔƠƯăâêôơư1234567890',
    zalgo: '̴̵̶̷̸̡̢̧̨̛̖̗̘̙̜̝̞̟̠̣̤̥̦̩̪̫̬̭̮̯̰̱̲̳̹̺̻̼͇͈͉͍͎̀́̂̃̄̅̆̇̈̉̊̋̌̍̎̏̐̑̒̓̔̽̾̿̀́͂̓̈́͆͊͋͌̕̚ͅ ͓͔͕͖͙͚͐͑͒͗͛ͣͤͥͦͧͨͩͪͫͬͭͮͯ͘͜͟͢͝͞͠͡͏҉',
    neo: '!<>-_\\/[]{}—=+*^?#________',
    uppercase: '1234567890QWERTYUIOPASDFGHJKLZXCVBNM#$%',
};
const presets = {
    default: {
        steps: [1, 8],
        interval: [60, 170],
        initialDelay: [0, 2000],
        changeChance: 0.6,
        ghostChance: 0.2,
        maxGhosts: 0.2,
        glyphs: glyphs.full + glyphs.zalgo,
        glyphsFromString: false,
        oneAtATime: 0,
        html: false,
        fillSpace: true,
        letterize: false,
        endless: false,
        startFrom: 'matching',
    },
    nier: {
        maxGhosts: 0,
        ghostChance: 0,
        changeChance: 0.8,
        steps: 2,
        interval: 10,
        initialDelay: 0,
        glyphs: glyphs.nier,
        oneAtATime: true,
        fillSpace: false,
        startFrom: 'erase',
        glyphsFromString: true,
    },
    typewriter: {
        interval: [50, 150],
        initialDelay: 0,
        steps: 0,
        changeChance: 0,
        maxGhosts: 0,
        glyphs: '',
        glyphsFromString: false,
        oneAtATime: true,
        fillSpace: false,
        startFrom: 'erase',
    },
    terminal: {
        interval: [25, 30],
        initialDelay: [0, 0],
        steps: 0,
        changeChance: 0.5,
        maxGhosts: 0,
        glyphs: '',
        oneAtATime: true,
        fillSpace: false,
        glyphsFromString: false,
        startFrom: 'erase',
    },
    zalgo: {
        initialDelay: [0, 3000],
        interval: [10, 35],
        steps: [0, 30],
        maxGhosts: 4.6,
        changeChance: 0.5,
        ghostChance: 0.7,
        glyphs: glyphs.zalgo,
        glyphsFromString: true,
        fillSpace: false,
    },
    neo: {
        glyphs: glyphs.neo,
        maxGhosts: 0,
        ghostChance: 0,
        changeChance: 1,
        interval: [30, 100],
        initialDelay: [0, 1300],
        steps: [4, 7],
        startFrom: 'previous',
        letterize: true,
    },
    encrypted: {
        glyphs: glyphs.uppercase,
        maxGhosts: 0,
        ghostChance: 0,
        changeChance: 1,
        interval: [50, 90],
        initialDelay: [0, 1300],
        steps: [5, 8],
        startFrom: 'previous',
        fillSpace: false,
        letterize: true,
    },
};// eslint-disable-next-line import/no-extraneous-dependencies
class Options {
    constructor(writer, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        this.steps = (_a = options.steps) !== null && _a !== void 0 ? _a : presets.default.steps;
        this.interval = (_b = options.interval) !== null && _b !== void 0 ? _b : presets.default.interval;
        this.initialDelay = (_c = options.initialDelay) !== null && _c !== void 0 ? _c : presets.default.initialDelay;
        this.changeChance = (_d = options.changeChance) !== null && _d !== void 0 ? _d : presets.default.changeChance;
        this.ghostChance = (_e = options.ghostChance) !== null && _e !== void 0 ? _e : presets.default.ghostChance;
        this.maxGhosts = (_f = options.maxGhosts) !== null && _f !== void 0 ? _f : presets.default.maxGhosts;
        this.glyphs = (_g = options.glyphs) !== null && _g !== void 0 ? _g : presets.default.glyphs;
        this.glyphsFromString =
            (_h = options.glyphsFromString) !== null && _h !== void 0 ? _h : presets.default.glyphsFromString;
        if (Number.isInteger(options.oneAtATime))
            this.oneAtATime = options.oneAtATime;
        else
            this.oneAtATime = options.oneAtATime ? 1 : 0;
        this.html = (_j = options.html) !== null && _j !== void 0 ? _j : presets.default.html;
        this.letterize = (_k = options.letterize) !== null && _k !== void 0 ? _k : presets.default.letterize;
        if (typeof document === 'undefined')
            this.letterize = false;
        this.endless = (_l = options.endless) !== null && _l !== void 0 ? _l : presets.default.endless;
        this.startFrom = (_m = options.startFrom) !== null && _m !== void 0 ? _m : presets.default.startFrom;
        this.writer = writer;
        this.fillSpace = (_o = options.fillSpace) !== null && _o !== void 0 ? _o : presets.default.fillSpace;
    }
    set glyphs(glyphs) {
        this.glyphsString = parseCharset(glyphs);
        this.setCharset();
    }
    set fillSpace(doFillSpace) {
        this.space = doFillSpace ? ' ' : '';
    }
    get stepsLeft() {
        return getRandomFromRange(this.steps);
    }
    get genInterval() {
        return getRandomFromRange(this.interval);
    }
    get genInitDelay() {
        return getRandomFromRange(this.initialDelay);
    }
    get genMaxGhosts() {
        if (Number.isInteger(this.maxGhosts))
            return this.maxGhosts;
        let length;
        if (this.writer.options.html)
            length = filterHtml(this.writer.goalString).length;
        else
            length = this.writer.goalString.length;
        return Math.round((length || 20) * this.maxGhosts);
    }
    get ghost() {
        var _a;
        return (_a = getRandom(this.ghostCharset)) !== null && _a !== void 0 ? _a : '';
    }
    setCharset() {
        let charset = this.glyphsString;
        if (this.glyphsFromString)
            charset += filterDuplicates(this.writer.previousString +
                (this.writer.options.html
                    ? filterHtml(this.writer.goalString)
                    : this.writer.goalString));
        this.ghostCharset = [...charset].filter(l => !['\t', '\n', '\r', '\f', '\v'].includes(l));
    }
}class State {
    constructor(writer) {
        this.nGhosts = 0;
        this.isTyping = false;
        this.isPaused = false;
        this.finished = false;
        this.writer = writer;
        this.maxGhosts = this.writer.options.genMaxGhosts;
    }
    get ghostsInLimit() {
        return this.nGhosts < this.maxGhosts;
    }
    play() {
        this.isTyping = true;
        this.isPaused = false;
        this.finished = false;
        this.toggleClass(true);
        this.maxGhosts = this.writer.options.genMaxGhosts;
    }
    pause() {
        this.isTyping = false;
        this.isPaused = true;
        this.toggleClass(false);
    }
    finish() {
        this.isTyping = false;
        this.finished = true;
        this.toggleClass(false);
    }
    toggleClass(enable) {
        const el = this.writer.htmlElement, className = 'gw-writing';
        if (!el)
            return;
        enable ? animateWithClass(el, className) : el.classList.remove(className);
    }
}var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Char {
    constructor(writer, l, gl, initialGhosts = '', isTag = false) {
        this.ghostsBefore = [];
        this.ghostsAfter = [];
        this.stop = false;
        this.isTag = false;
        this.isWhitespace = false;
        this.afterGlitchChance = 0;
        this.writer = writer;
        this.setProps(l, gl, initialGhosts, isTag);
        if (writer.options.letterize) {
            this.els = {
                ghostsBeforeEl: document.createElement('span'),
                letterEl: document.createElement('span'),
                ghostsAfterEl: document.createElement('span'),
            };
            this.els.ghostsBeforeEl.className = 'gw-ghosts';
            this.els.ghostsAfterEl.className = 'gw-ghosts';
            this.els.letterEl.className = 'gw-letter';
        }
    }
    setProps(l, gl, initialGhosts = '', isTag = false) {
        const { options } = this.writer;
        this.l = l;
        this.gl = gl;
        this.isTag = isTag;
        this.ghostsBefore = [...initialGhosts];
        this.writer.state.nGhosts += initialGhosts.length;
        this.stepsLeft = options.stepsLeft;
        if (isTag)
            this.stepsLeft = 0;
        this.isWhitespace = isSpecialChar(gl);
        this.afterGlitchChance =
            (options.ghostChance + options.changeChance) / 3.7;
    }
    reset(l, gl, initialGhosts = '', isTag = false) {
        this.setProps(l, gl, initialGhosts, isTag);
        if (this.els)
            this.els.letterEl.className = 'gw-letter';
    }
    get string() {
        const { l: char, ghostsAfter, ghostsBefore } = this;
        return ghostsBefore.join('') + char + ghostsAfter.join('');
    }
    get finished() {
        const { l: char, gl: goal, ghostsBefore, ghostsAfter } = this;
        return ((char === goal &&
            ghostsBefore.length === 0 &&
            ghostsAfter.length === 0) ||
            this.isTag);
    }
    get interval() {
        let interval = this.writer.options.genInterval;
        if (this.isWhitespace)
            interval /= 2;
        return interval;
    }
    writeToElement() {
        if (!this.els)
            return;
        const { ghostsBeforeEl, ghostsAfterEl, letterEl } = this.els;
        letterEl.innerHTML = this.l;
        ghostsBeforeEl.textContent = this.ghostsBefore.join('');
        ghostsAfterEl.textContent = this.ghostsAfter.join('');
    }
    set spanElement(el) {
        if (!this.els)
            return;
        this.els.charEl = el;
        this.appendChildren();
    }
    appendChildren() {
        var _a, _b;
        (_b = (_a = this.els) === null || _a === void 0 ? void 0 : _a.charEl) === null || _b === void 0 ? void 0 : _b.append(this.els.ghostsBeforeEl, this.els.letterEl, this.els.ghostsAfterEl);
        this.writeToElement();
    }
    type() {
        var _a, _b, _c;
        return __awaiter$1(this, void 0, void 0, function* () {
            const { writer } = this;
            if (this.isTag) {
                this.l = this.gl;
                writer.emiter.call('step');
                return true;
            }
            const loop = () => __awaiter$1(this, void 0, void 0, function* () {
                yield wait(this.interval);
                const lastString = this.string;
                this.step();
                if (lastString !== this.string) {
                    writer.emiter.call('step');
                    this.writeToElement();
                }
                !writer.options.endless && this.stepsLeft--;
            });
            yield wait(writer.options.genInitDelay);
            yield promiseWhile(() => (!this.finished || writer.options.endless) &&
                !writer.state.isPaused &&
                !this.stop, loop);
            if (this.finished) {
                (_b = (_a = this.els) === null || _a === void 0 ? void 0 : _a.charEl) === null || _b === void 0 ? void 0 : _b.classList.add('gw-finished');
                (_c = this.els) === null || _c === void 0 ? void 0 : _c.letterEl.classList.remove('gw-glitched');
            }
            return this.finished;
        });
    }
    step() {
        var _a, _b;
        const { writer } = this;
        if ((this.stepsLeft > 0 && this.l !== this.gl) ||
            (coinFlip(this.afterGlitchChance) && !this.isWhitespace) ||
            writer.options.endless) {
            /**
             * IS GROWING
             */
            const { ghostChance, changeChance } = writer.options;
            if (coinFlip(ghostChance)) {
                if (writer.state.ghostsInLimit)
                    this.addGhost();
                else
                    this.removeGhost();
            }
            if (coinFlip(changeChance)) {
                (_a = this.els) === null || _a === void 0 ? void 0 : _a.letterEl.classList.add('gw-glitched');
                this.l = writer.options.ghost;
            }
        }
        else if (!this.finished) {
            /**
             * IS SHRINKING
             */
            (_b = this.els) === null || _b === void 0 ? void 0 : _b.letterEl.classList.remove('gw-glitched');
            this.l = this.gl;
            this.removeGhost();
        }
    }
    addGhost() {
        const l = this.writer.options.ghost;
        this.writer.state.nGhosts++;
        coinFlip()
            ? insertGhost(this.ghostsBefore, l)
            : insertGhost(this.ghostsAfter, l);
    }
    removeGhost() {
        const deleted = coinFlip() && this.ghostsBefore.length > 0
            ? deleteRandom(this.ghostsBefore)
            : deleteRandom(this.ghostsAfter);
        if (deleted)
            this.writer.state.nGhosts--;
    }
}
function insertGhost(ghostsArray, ghost) {
    const { length } = ghostsArray;
    ghostsArray.splice(random(0, length, 'floor'), 0, ghost);
}class Emiter {
    constructor(writer, onStepCallback, onFinishCallback) {
        this.onStepCallback = onStepCallback;
        this.onFinishCallback = onFinishCallback;
        this.writer = writer;
    }
    call(eventType) {
        var _a, _b;
        this.writer.updateString();
        const { htmlElement, writerData, string } = this.writer;
        if (htmlElement && !this.writer.options.letterize) {
            if (this.writer.options.html)
                htmlElement.innerHTML = string;
            else
                htmlElement.textContent = string;
        }
        htmlElement === null || htmlElement === void 0 ? void 0 : htmlElement.setAttribute('data-gw-string', this.writer.options.html ? filterHtml(string) : string);
        if (eventType === 'finish') {
            // ON FINISH
            this.writer.state.finish();
            (_a = this.onFinishCallback) === null || _a === void 0 ? void 0 : _a.call(this, string, writerData);
            this.emitEvent();
        }
        else {
            // ON STEP
            (_b = this.onStepCallback) === null || _b === void 0 ? void 0 : _b.call(this, string, writerData);
        }
    }
    emitEvent() {
        const { htmlElement, writerData } = this.writer;
        if (!htmlElement || typeof CustomEvent === 'undefined')
            return;
        htmlElement === null || htmlElement === void 0 ? void 0 : htmlElement.dispatchEvent(new CustomEvent('gw-finished', { detail: writerData }));
    }
}var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class GlitchedWriter {
    /**
     * Create new instance of Glitched Writer, that manages writing text to one HTML Element. Few writers can possess the same HTML Element, but don't write with them at the same time.
     * Use .write(string) method to start writing.
     * @param htmlElement HTML Element OR a Selector string (eg. '.text')
     * @param options Options object (eg. { html: true, ... }) OR preset name (eg. 'zalgo').
     * @param onStepCallback Callback, that will be triggered on every step. Params passed: string & writer data.
     * @param onFinishCallback Callback, that will be triggered when each writing finishes. Params passed: string & writer data.
     */
    constructor(htmlElement, options, onStepCallback, onFinishCallback) {
        var _a;
        this.charTable = [];
        this.goalString = '';
        this.string = '';
        if (typeof htmlElement === 'string') {
            this.htmlElement = (_a = document.querySelector(htmlElement)) !== null && _a !== void 0 ? _a : undefined;
        }
        else
            this.htmlElement = htmlElement !== null && htmlElement !== void 0 ? htmlElement : undefined;
        if (this.htmlElement)
            this.htmlElement.$writer = this;
        if (typeof options === 'string')
            this.preset = options;
        else
            this.setOptions(options !== null && options !== void 0 ? options : {});
        this.state = new State(this);
        this.emiter = new Emiter(this, onStepCallback, onFinishCallback);
        this.string = this.previousString;
    }
    /**
     * Function for updating multiple options at once. Unlike options setter, it doesn't reset not-passed fields to default state.
     * @param options Options object, with fields you want to change.
     */
    extendOptions(options) {
        this.setOptions(Object.assign(Object.assign({}, this.options), options));
    }
    setOptions(options) {
        this.options = new Options(this, options);
    }
    set preset(preset) {
        this.options = new Options(this, presets[preset]);
    }
    updateString() {
        this.string = this.charTable.map(char => char.string).join('');
    }
    get previousString() {
        var _a;
        let prev = (_a = this.htmlElement) === null || _a === void 0 ? void 0 : _a.textContent;
        if (typeof prev !== 'string')
            prev = this.options.html ? filterHtml(this.string) : this.string;
        prev = prev.trim();
        return prev;
    }
    /**
     * All the data, about current state of the writer instance.
     */
    get writerData() {
        const writer = this, { options, state, string } = this;
        return {
            string,
            writer,
            options,
            state,
        };
    }
    /**
     * Main function of Glitched Writer. It orders writer to start typing passed string. Can be called multiple times after each other, or even during writing.
     * @param string text, that will get written.
     * @returns Promise, with writer data result
     */
    write(string, writeOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.options.startFrom === 'erase' && !(writeOptions === null || writeOptions === void 0 ? void 0 : writeOptions.erase))
                yield this.write(this.genGoalStringToErase(string), { erase: true });
            this.goalString = string;
            this.state.nGhosts = 0;
            this.options.setCharset();
            if (this.options.startFrom === 'matching')
                this.createMatchingCharTable();
            else
                this.createPreviousCharTable();
            // this.logCharTable()
            this.letterize();
            // console.log(
            // 	this.charTable.map(char => [
            // 		char.gl,
            // 		char.isTag,
            // 		char.letterize?.charEl?.outerHTML,
            // 	]),
            // )
            this.pause();
            return this.play({
                reverse: this.options.oneAtATime !== 0 && (writeOptions === null || writeOptions === void 0 ? void 0 : writeOptions.erase),
            });
        });
    }
    /**
     * Add text to end method. Orders writer to write same string as previous, but with this added at the end.
     * @param string text that will get added
     * @returns Promise, with writer data result
     */
    add(string) {
        return __awaiter(this, void 0, void 0, function* () {
            const { previousString } = this;
            return this.write(previousString + string);
        });
    }
    /**
     * Remove last n-letters method. Orders writer to write same string as previous, but without n-letters at the end.
     * @param n number of letters to remove.
     * @returns Promise, with writer data result
     */
    remove(n) {
        return __awaiter(this, void 0, void 0, function* () {
            const { previousString } = this, array = Array.from(previousString);
            array.splice(-n);
            return this.write(array.join(''), { erase: true });
        });
    }
    // private logCharTable() {
    // 	console.table(
    // 		this.charTable.map(
    // 			({ ghostsBefore, ghostsAfter, l, gl, isTag, isWhitespace }) => [
    // 				ghostsBefore.join(''),
    // 				ghostsAfter.join(''),
    // 				l,
    // 				gl,
    // 				(isTag && 'TAG') || (isWhitespace && 'Whitespace'),
    // 			],
    // 		),
    // 	)
    // }
    /**
     * Resume last writing order.
     * @returns Promise, with writer data result
     */
    play(playOptions) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const playList = [], { charTable } = this;
            if (this.state.isTyping)
                return this.getWriterData('ERROR', `The writer is already typing "${this.goalString}".`);
            this.state.play();
            /**
             * ONE AT A TIME
             */
            if (this.options.oneAtATime > 0) {
                const reverse = (_a = playOptions === null || playOptions === void 0 ? void 0 : playOptions.reverse) !== null && _a !== void 0 ? _a : false, charTableCopy = reverse ? [...charTable] : [...charTable].reverse();
                // Char executor - runs a loop, typing one char at a time
                // It is possible to run multiple of them at the same time
                const executor = () => __awaiter(this, void 0, void 0, function* () {
                    let lastResult = true, ended = false;
                    const loop = () => __awaiter(this, void 0, void 0, function* () {
                        var _b;
                        const lastChar = charTableCopy.pop();
                        if (!lastChar)
                            ended = true;
                        else
                            lastResult = (_b = (yield lastChar.type())) !== null && _b !== void 0 ? _b : false;
                    });
                    yield promiseWhile(() => !ended && lastResult && !this.state.isPaused, loop);
                    return lastResult;
                });
                // Add as many executors as needed to the playList
                for (let n = 0; n < this.options.oneAtATime; n++) {
                    playList.push(executor());
                }
            }
            /**
             * NORMAL
             */
            // Add every char .type() at once.
            else
                charTable.forEach(char => playList.push(char.type()));
            try {
                const finished = (yield Promise.all(playList)).every(result => result);
                return this.returnResult(finished);
            }
            catch (error) {
                return this.getWriterData('ERROR', 'Writer encountered an error.', error);
            }
        });
    }
    /**
     * Pause current writer task.
     */
    pause() {
        this.state.pause();
    }
    returnResult(finished) {
        finished ? this.emiter.call('finish') : this.emiter.call('step');
        return finished
            ? this.getWriterData('SUCCESS', `The writer finished typing.`)
            : this.getWriterData('ERROR', `Writer failed to finish typing.`);
    }
    createMatchingCharTable() {
        const { goalStringArray, previousString: previous } = this, maxDist = Math.min(Math.ceil(this.options.genMaxGhosts / 2), 5);
        let pi = -1;
        goalStringArray.forEach((gl, gi) => {
            pi++;
            if (gl.type === 'tag') {
                pi--;
                this.setChar(gi, '', gl);
                return;
            }
            const fi = gl.value !== '' ? previous.indexOf(gl.value, pi) : -1;
            if (fi !== -1 && fi - pi <= maxDist) {
                const appendedText = previous.substring(pi, fi);
                this.setChar(gi, gl.value, gl, appendedText);
                pi = fi;
            }
            else
                this.setChar(gi, previous[pi], gl);
        });
        this.removeExtraChars(goalStringArray.length);
    }
    createPreviousCharTable() {
        const { goalStringArray, previousString: previous } = this;
        let pi = -1;
        goalStringArray.forEach((gl, gi) => {
            pi++;
            if (gl.type === 'tag') {
                pi--;
                this.setChar(gi, '', gl);
                return;
            }
            this.setChar(gi, previous[pi], gl);
        });
        this.removeExtraChars(goalStringArray.length);
    }
    letterize() {
        if (!this.options.letterize || !this.htmlElement)
            return;
        const html = this.charTable
            .map(({ isTag, gl }) => (isTag ? gl : '<span class="gw-char"></span>'))
            .join('');
        this.htmlElement.innerHTML = html;
        const spans = this.htmlElement.querySelectorAll('span.gw-char');
        let i = 0;
        this.charTable.forEach(char => {
            if (char.isTag)
                return;
            char.spanElement = spans[i];
            i++;
        });
    }
    removeExtraChars(from) {
        const { charTable } = this;
        charTable.splice(from, charTable.length - from);
    }
    setChar(ci, pl, gl, appendedText) {
        const { charTable } = this, char = charTable[ci];
        char
            ? char.reset(pl !== null && pl !== void 0 ? pl : '', gl.value || this.options.space, appendedText, gl.type === 'tag')
            : charTable.push(new Char(this, pl !== null && pl !== void 0 ? pl : '', gl.value || this.options.space, appendedText, gl.type === 'tag'));
    }
    get goalStringArray() {
        const { goalString: goal, options, previousString } = this, goalArray = options.html
            ? htmlToArray(goal)
            : stringToLetterItems(goal), diff = Math.max(0, previousString.length - goalArray.length);
        if (this.options.oneAtATime)
            return goalArray.concat(stringToLetterItems(arrayOfTheSame('', diff)));
        const nBefore = Math.ceil(diff / 2), nAfter = Math.floor(diff / 2);
        return stringToLetterItems(arrayOfTheSame('', nBefore)).concat(goalArray, stringToLetterItems(arrayOfTheSame('', nAfter)));
    }
    getWriterData(status, message, error) {
        const { writerData } = this;
        return Object.assign(Object.assign({}, writerData), { status,
            message,
            error });
    }
    genGoalStringToErase(goal) {
        var _a;
        const { previousString: previous } = this;
        let result = '';
        for (let i = 0; i < goal.length; i++) {
            const gl = goal[i], pl = (_a = previous[i]) !== null && _a !== void 0 ? _a : '';
            if (gl === pl)
                result += pl;
            else
                break;
        }
        const diff = Math.max(goal.length - result.length, 0);
        if (diff > 0 && this.options.space === ' ')
            result = result.padEnd(diff + result.length, ' ');
        return result;
    }
}var script = /*#__PURE__*/Vue__default['default'].extend({
  name: 'GlitchedWriter',
  props: {
    text: {
      type: String,
      required: true
    },
    pause: {
      type: Boolean,
      default: false
    },
    options: {
      type: Object,
      default: function _default() {}
    },
    preset: {
      type: String,
      default: 'default'
    }
  },
  data: function data() {
    return {
      writer: null
    };
  },
  computed: {
    appear: function appear() {
      return typeof this.$attrs.appear !== 'undefined';
    },
    basePreset: function basePreset() {
      var _presets;

      return (_presets = presets[this.preset]) !== null && _presets !== void 0 ? _presets : {};
    }
  },
  watch: {
    text: function text() {
      this.write();
    },
    options: function options() {
      this.setOptions();
    },
    preset: function preset() {
      this.setOptions();
    },
    pause: function pause(paused) {
      paused ? this.writer.pause() : this.writer.play();
    }
  },
  methods: {
    setOptions: function setOptions() {
      this.writer.setOptions(_objectSpread2(_objectSpread2({}, this.basePreset), this.options));
    },
    setTextContent: function setTextContent(text) {
      if (this.writer.options.html) this.$el.innerHTML = text;else this.$el.textContent = text;
    },
    step: function step(string, writerData) {
      this.$emit('step', string, writerData);
    },
    finish: function finish() {
      if (this.pause) return;
      var _this$writer = this.writer,
          string = _this$writer.string,
          writerData = _this$writer.writerData;
      this.$emit('finish', string, writerData);
    },
    write: function write() {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.writer.write(_this.text);

              case 2:
                _this.finish();

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    }
  },
  mounted: function mounted() {
    this.writer = new GlitchedWriter(this.$el, this.options, this.step);
    this.setTextContent(this.text);

    if (this.appear) {
      this.setTextContent('');
      this.write();
      this.pause && this.writer.pause();
    }
  }
});function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
        createInjectorSSR = createInjector;
        createInjector = shadowMode;
        shadowMode = false;
    }
    // Vue.extend constructor export interop.
    const options = typeof script === 'function' ? script.options : script;
    // render functions
    if (template && template.render) {
        options.render = template.render;
        options.staticRenderFns = template.staticRenderFns;
        options._compiled = true;
        // functional template
        if (isFunctionalTemplate) {
            options.functional = true;
        }
    }
    // scopedId
    if (scopeId) {
        options._scopeId = scopeId;
    }
    let hook;
    if (moduleIdentifier) {
        // server build
        hook = function (context) {
            // 2.3 injection
            context =
                context || // cached call
                    (this.$vnode && this.$vnode.ssrContext) || // stateful
                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
            // 2.2 with runInNewContext: true
            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                context = __VUE_SSR_CONTEXT__;
            }
            // inject component styles
            if (style) {
                style.call(this, createInjectorSSR(context));
            }
            // register component module identifier for async chunk inference
            if (context && context._registeredComponents) {
                context._registeredComponents.add(moduleIdentifier);
            }
        };
        // used by ssr in case component is cached and beforeCreate
        // never gets called
        options._ssrRegister = hook;
    }
    else if (style) {
        hook = shadowMode
            ? function (context) {
                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
            }
            : function (context) {
                style.call(this, createInjector(context));
            };
    }
    if (hook) {
        if (options.functional) {
            // register for functional component in vue file
            const originalRender = options.render;
            options.render = function renderWithStyleInjection(h, context) {
                hook.call(context);
                return originalRender(h, context);
            };
        }
        else {
            // inject component registration as beforeCreate hook
            const existing = options.beforeCreate;
            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
    }
    return script;
}/* script */
var __vue_script__ = script;
/* template */

var __vue_render__ = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('span', {
    staticClass: "glitched-writer"
  }, []);
};

var __vue_staticRenderFns__ = [];
/* style */

var __vue_inject_styles__ = undefined;
/* scoped */

var __vue_scope_id__ = undefined;
/* module identifier */

var __vue_module_identifier__ = "data-v-072f7669";
/* functional template */

var __vue_is_functional_template__ = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__ = /*#__PURE__*/normalizeComponent({
  render: __vue_render__,
  staticRenderFns: __vue_staticRenderFns__
}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);// Import vue component

// Default export is installable instance of component.
// IIFE injects install function into component, allowing component
// to be registered via Vue.use() as well as Vue.component(),
var component = /*#__PURE__*/(function () {
  // Assign InstallableComponent type
  var installable = __vue_component__; // Attach install function executed by Vue.use()

  installable.install = function (Vue) {
    Vue.component('GlitchedWriter', installable);
  };

  return installable;
})(); // It's possible to expose named exports when writing components that can
// also be used as directives, etc. - eg. import { RollupDemoDirective } from 'rollup-demo';
// export const RollupDemoDirective = directive;
var namedExports=/*#__PURE__*/Object.freeze({__proto__:null,'default': component});// only expose one global var, with named exports exposed as properties of
// that global var (eg. plugin.namedExport)

Object.entries(namedExports).forEach(function (_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      exportName = _ref2[0],
      exported = _ref2[1];

  if (exportName !== 'default') component[exportName] = exported;
});module.exports=component;